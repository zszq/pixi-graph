<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>pixi-graph</title>
  <script src="https://unpkg.com/graphology@0.19.3/dist/graphology.umd.js"></script>
  <script src="https://unpkg.com/graphology-layout-forceatlas2@0.4.4/build/graphology-layout-forceatlas2.js"></script>
  <script src="https://unpkg.com/fontfaceobserver@2.1.0/fontfaceobserver.standalone.js"></script>
  <!-- <script src="https://unpkg.com/pixi-graph@1.3.0/dist/pixi-graph.umd.min.js"></script> -->
  <script src="../dist/pixi-graph.umd.js"></script>
  <!-- <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> -->
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="//unpkg.com/layui@2.6.7/dist/layui.js"></script>
  <link rel="stylesheet" href="./font.css">
  <style>
    body {
      margin: 0;
    }
    #graph {
      width: 100vw;
      height: 100vh;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
    }
    #controls button {
      background-color: #fff;
      border: 1px solid #ccc;
      cursor: pointer;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div id="graph"></div>
  <div id="controls">
    <button id="add-node">Add Node</button>
    <!-- <button id="add-edge">Add Edge</button>
    <button id="drop-node">Drop Node</button>
    <button id="drop-edge">Drop Edge</button>
    <button id="clear">Clear</button>
    <button id="clear-edges">Clear Edges</button>
    <button id="update-node">Update Node</button>
    <button id="update-edge">Update Edge</button>
    <button id="update-nodes">Update Nodes</button>
    <button id="update-edges">Update Edges</button>
    <button id="export">Export</button>
    <button id="import">Import</button>
    <div style="height: 10px"></div>
    <button id="zoom-in">Zoom In</button>
    <button id="zoom-out">Zoom Out</button>
    <button id="reset-view">Reset View</button>
    <button id="multiSelect">多选</button>
    <button id="correlation">关联</button> -->
  </div>

<script>
// d3.schemeCategory10
// const colors = [
//   '#1f77b4',
//   '#ff7f0e',
//   '#2ca02c',
//   '#d62728',
//   '#9467bd',
//   '#8c564b',
//   '#e377c2',
//   '#7f7f7f',
//   '#bcbd22',
//   '#17becf',
// ];

const NODE_COLOR_NORMAL = '#1f77b4';
const EDGE_COLOR_NORMAL = '#cccccc';
const COLOR_SELECTED = '#ff7f0e';



window.addEventListener('DOMContentLoaded', async () => {
  // let statusSelected = false;
  // let statusCorrelation = false;

  // document.getElementById('multiSelect').addEventListener('click', (e) => {
  //   statusSelected = !statusSelected;
  //   event.target.style.backgroundColor = statusSelected ? '#ccc' : '#fff';
  //   selectedNodes = [];
  //   resetGraph();
  // });
  // document.getElementById('correlation').addEventListener('click', (e) => {
  //   statusCorrelation = !statusCorrelation;
  //   event.target.style.backgroundColor = statusCorrelation ? '#ccc' : '#fff';
  //   selectedNodes = [];
  //   resetGraph();
  // });

  // let selectedNodes = [];
  // let selectedLinks = [];



  const graph = new graphology.Graph({
    multi: true,
    type: 'undirected'
  });
  // // const { nodes, links } = await (await fetch('miserables.json')).json();
  // const { nodes, links } = await (await fetch('data1-1.json')).json();
  // // const { nodes, links } = await (await fetch('socfb-Caltech36.json')).json();
  // nodes.forEach(node => {
  //   graph.addNode(node.id, {...node});
  // });
  // links.forEach(link => {
  //   // graph.addEdge(link.source, link.target, {...link});
  //   graph.addEdgeWithKey(`${link.source}->${link.target}`, link.source, link.target, {...link});
  // });

  // // layout
  // graph.forEachNode(node => {
  //   graph.setNodeAttribute(node, 'x', Math.random());
  //   graph.setNodeAttribute(node, 'y', Math.random());
  // });
  // console.time('compute');
  // forceAtlas2.assign(graph, { iterations: 300, settings: { ...forceAtlas2.inferSettings(graph), scalingRatio: 80 }});
  // console.timeEnd('compute');
  // // const positions = await (await fetch('position2.json')).json();
  // // graph.forEachNode(node => {
  // //   const position = positions[node];
  // //   graph.setNodeAttribute(node, 'x', position.x);
  // //   graph.setNodeAttribute(node, 'y', position.y);
  // // });
  graph.addNode('node0', {
    id: "node0",
    group: 4,
    label: "标签0",
    icon: 'http://127.0.0.1:8080/docs/images/ba.png',
    // icon: 'http://127.0.0.1:8080/docs/images/bz.jpeg',
    x: 1,
    y: 2
  });
  graph.addNode('node1', {
    id: "node1",
    group: 1,
    label: "标签1",
    // icon: 'http://127.0.0.1:8080/docs/images/ok.png',
    icon: 'http://127.0.0.1:8080/docs/images/yz.png',
    // icon: 'http://192.168.224.78:8080/chain/virtual/node/icon/exchange-OkLink.com.png',
    x: 1,
    y: 300
  });
  graph.addNode('node2', {
    id: "node2",
    group: 2,
    label: "标签2",
    // icon: 'http://127.0.0.1:8080/docs/images/ok.png',
    icon: 'http://127.0.0.1:8080/docs/images/bz.jpeg',
    // icon: 'http://192.168.224.78:8080/chain/virtual/node/icon/exchange-OkLink.com.png',
    x: 300,
    y: 2
  });
  graph.addEdgeWithKey(`node0->node1`, 'node0', 'node1', {
    source: "node0",
    target: "node1",
    label: "交易500元",
    value: 4
  });
  graph.addEdgeWithKey(`node0->node2`, 'node0', 'node2', {
    source: "node0",
    target: "node2",
    label: "交易500元",
    value: 4
  });
  graph.addEdgeWithKey(`node1->node2`, 'node1', 'node2', {
    source: "node1",
    target: "node2",
    label: "交易500元",
    value: 4
  });
  // graph.clear();
  // function setCenter() {
  //   const WORLD_PADDING = 100;
  //   const nodesX = graph.nodes().map(nodeKey => graph.getNodeAttribute(nodeKey, 'x'));
  //   const nodesY = graph.nodes().map(nodeKey => graph.getNodeAttribute(nodeKey, 'y'));
  //   const minX = Math.min(...nodesX);
  //   const maxX = Math.max(...nodesX);
  //   const minY = Math.min(...nodesY);
  //   const maxY = Math.max(...nodesY);

  //   const graphWidth = Math.abs(maxX - minX);
  //   const graphHeight = Math.abs(maxY - minY);
  //   const graphCenter ={x: minX + graphWidth / 2, y: minY + graphHeight / 2};

  //   const worldWidth = graphWidth + WORLD_PADDING * 2;
  //   const worldHeight = graphHeight + WORLD_PADDING * 2;
    
  //   // TODO: update worldWidth/worldHeight when graph is updated?
  //   pixiGraph.viewport.resize(document.getElementById('graph').clientWidth, document.getElementById('graph').clientHeight, worldWidth, worldHeight);

  //   pixiGraph.viewport.setZoom(1); // otherwise scale is 0 when initialized in React useEffect
  //   pixiGraph.viewport.center = graphCenter;
  //   pixiGraph.viewport.fit(true);
  // }
  
  const style = {
    node: {
      size: node => 20,
      color: node => NODE_COLOR_NORMAL,
      shape: 'circle', // circle or rect
      border: {
        width: 2,
        color: '#ccc',
      },
      icon: {
        type: PixiGraph.TextType.TEXT, // TEXT or IMAGE
        content: (node) => {
          return node.icon;
          // let unicode = '&#xe7f8;';
          // if (unicode === "") return "";
          // const num = unicode.replace("&#x", "").replace(";", "");
          // const str = String.fromCharCode(parseInt(num, 16).toString(10));
          // return str;
        },
        fontFamily: 'iconfont',
        fontSize: node => (node.group + 20),
        color: '#ffffff',
      },
      label: {
        content: node => node.label ? node.label : node.id,
        type: PixiGraph.TextType.TEXT,
        fontFamily: 'HelveticaRegular',
        fontSize: 10,
        fontWeight: '400',
        color: '#000',
        backgroundColor: 'rgba(255, 255, 255, 0)',
        padding: 2,
      },
    },
    edge: {
      width: edge => 2,
      color: edge => '#000',
      selefLoop: { // 自循环线的样式
        radius: 30,  // 圆环半径
        cross: 10 // 交叉距离
      },
      gap: 20, // 两根平行线之间的间距
      bilateralKey: 'reverse', // 判断是否存在相反线的关键字，用于查看下级节点时使用，需在线属性设置此key和相应的boolean值。
      arrow: {
        show: true,
        size: edge => (Math.log((edge.value || 0) + 1) + 2) * 5, // 根据edge.width设置避免被覆盖,如果不能被2整除会自动加1像素，防止发生偏移
      },
      label: {
        content: edge => edge.label ? edge.label : edge.target,
        type: PixiGraph.TextType.TEXT,
        fontFamily: 'HelveticaRegular',
        fontSize: 10,
        fontWeight: '500',
        color: '#000',
        backgroundColor: 'rgba(255, 255, 255, 0)',
        padding: 2,
      },
    },
  };
  const hoverStyle = {
    node: {
      border: {
        color: COLOR_SELECTED,
      },
      label: {
        // backgroundColor: COLOR_SELECTED,
        // color: '#ffffff',
        fontWeight: 'bolder',
      },
    },
    edge: {
      color: COLOR_SELECTED,
      label: {
        backgroundColor: COLOR_SELECTED,
        color: '#ffffff',
      },
    },
  };

  const resources = [
    { name: 'HelveticaRegular', url: 'https://gist.githubusercontent.com/zakjan/b61c0a26d297edf0c09a066712680f37/raw/8cdda3c21ba3668c3dd022efac6d7f740c9f1e18/HelveticaRegular.fnt' },
  ];
  await new FontFaceObserver('iconfont').load().then(() => console.log('Icons'));

  const pixiGraph = new PixiGraph.PixiGraph({
    container: document.getElementById('graph'),
    graph,
    style,
    hoverStyle,
    // resources,
    onprogress: (percentage) => {console.log(percentage)}
  });


  // 加载进度对外接口
  // pixiGraph.on('progress', (percentage) => console.log('progress', percentage));



  // pixiGraph.on('nodeClick', (event, nodeKey) => {
  //   console.log('nodeClick', event.type, nodeKey)
    
  //   if (statusCorrelation) {
  //     selectedNodes = [];
  //     let neighbors = graph.neighbors(nodeKey);
  //     selectedNodes = neighbors;
  //     selectedNodes.push(nodeKey);
  //     style.node.color = (node) => {
  //       return selectedNodes.includes(node.id) ? COLOR_SELECTED : NODE_COLOR_NORMAL;
  //     }
  //     style.edge.color = (edge) => {
  //       let {source, target} = edge;
  //       return (source === nodeKey || target === nodeKey) ? COLOR_SELECTED : EDGE_COLOR_NORMAL;
  //     }
  //     // layer.msg(nodeKey + '相关信息');
  //   } else if (statusSelected) {
  //     selectedNodes.push(nodeKey);
  //     style.node.color = (node) => {
  //       selectedNodes.push(nodeKey);
  //       return selectedNodes.includes(node.id) ? COLOR_SELECTED : NODE_COLOR_NORMAL;
  //     }
  //     style.edge.color = (edge) => {
  //       return EDGE_COLOR_NORMAL;
  //     }
  //   } else {
  //     selectedNodes = [];
  //     // layer.msg(nodeKey + '相关信息');
  //     style.node.color = (node) => {
  //       selectedNodes.push(nodeKey);
  //       return selectedNodes.includes(node.id) ? COLOR_SELECTED : NODE_COLOR_NORMAL;
  //     }
  //     style.edge.color = (edge) => {
  //       return EDGE_COLOR_NORMAL;
  //     }
  //   }
    
  //   updateNodes();
  //   updateEdges();
  // });

  // pixiGraph.on('edgeClick', (event, linkKey) => {
  //   console.log('edgeClick', event, linkKey)
  //   let [source, target] = graph.extremities(linkKey);
  //   style.node.color = node => (node.id === source || node.id === target) ? COLOR_SELECTED : NODE_COLOR_NORMAL;
  //   style.edge.color = edge => (edge.source === source && edge.target === target) ? COLOR_SELECTED : EDGE_COLOR_NORMAL;
    
  //   updateNodes();
  //   updateEdges();
  // });



  // const updateNodes = () => {
  //   graph.updateEachNodeAttributes((nodeKey, nodeAttributes) => {
  //     return {
  //       ...nodeAttributes
  //     };
  //   });
  // };

  // const updateEdges = () => {
  //   graph.updateEachEdgeAttributes((edgeKey, edgeAttributes) => {
  //     return {
  //       ...edgeAttributes
  //     };
  //   });
  // };
  
  // const resetGraph = () => {
  //   style.node.color = node => NODE_COLOR_NORMAL;
  //   style.edge.color = edge => EDGE_COLOR_NORMAL;

  //   updateNodes();
  //   updateEdges();
  // };




  


  const addLeaf = (nodeKey) => {
    const nodeAttr = graph.getNodeAttributes(nodeKey);
    // 可通过graphology-layout-forceatlas2进行布局
    let data = {
      nodes: [
        {id: "node100", group: 5, label: "标签100", icon: '', x: nodeAttr.x+50, y: nodeAttr.y+50},
        {id: "node200", group: 4, label: "标签200", icon: '', x: nodeAttr.x+100, y: nodeAttr.y+100},
        {id: "node300", group: 2, label: "标签300", icon: '', x: nodeAttr.x+150, y: nodeAttr.y+150}
      ],
      links: [
        {source: "node100", target: "node200", label: "交易200元", value: 4, reverse: true},
        {source: "node100", target: "node300", label: "交易600元", value: 7, reverse: true},
        {source: "node200", target: "node100", label: "交易600元", value: 1, reverse: true},
        {source: "node200", target: "node300", label: "交易600元", value: 2, reverse: false},
        {source: "node300", target: "node300", label: "交易600元", value: 8, reverse: false},
        {source: "node300", target: "node100", label: "交易600元", value: 6, reverse: true},
      ]
    }
    const {nodes, links} = data;
    // let graph2 = new graphology.Graph({ multi: true, type: 'undirected' });
    
    // nodes.forEach(node => {
    //   console.log('node', node);
    //   graph2.addNode(node.id, node);
    // })
    // links.forEach(link => {
    //   graph2.addEdge(link.source, link.target, link);
    // })
    // const positions = circular(graph2, {center: 80, scale: 100});
    // console.log('positions', positions);

    nodes.forEach((node) => {
      // node.x = positions[node.id].x + nodeAttr.x;
      // node.y = positions[node.id].y + nodeAttr.y;
      !graph.hasNode(node.id) && graph.addNode(node.id, node);
    })
    links.forEach((link) => {
      // !graph.edges(link.target, link.source).length > 1 && graph.mergeEdge(link.source, link.target);
      // console.log('hasEdge', graph.hasEdge(`${link.source}->${link.target}`));
      !graph.hasEdge(`${link.source}->${link.target}`) && graph.addEdgeWithKey(`${link.source}->${link.target}`, link.source, link.target, link);
      
    })
    // console.log('edges', graph.edges('node100', 'node200'));
  }
  
  // pixiGraph.on('viewClick', (event) => {
  //   console.log('viewClick', event, pixiGraph.viewport.center);
  // });
  
  pixiGraph.on('nodeClick', (event, nodeKey, nodeStyle) => {
    // pixiGraph.dragEnable();
    console.log('nodeClick', event, nodeKey, nodeStyle);
    // style.node.label.fontWeight = 'bolder';
    addLeaf(nodeKey);
  });
  pixiGraph.on('nodeRightclick', (event, nodeKey, nodeStyle) => {
    // pixiGraph.dragEnable();
    console.log('nodeRightclick', event, nodeKey, nodeStyle);
  });
  // pixiGraph.on('nodeMousemove', (event, nodeKey) => console.log('nodeMousemove', event, nodeKey));
  // pixiGraph.on('nodeMouseover', (event, nodeKey, nodeStyle) => {
  //   console.log('nodeMouseover', event, nodeKey, nodeStyle)
  // });
  // pixiGraph.on('nodeMouseout', (event, nodeKey) => console.log('nodeMouseout', event, nodeKey));
  // pixiGraph.on('nodeMousedown', (event, nodeKey) => console.log('nodeMousedown', event, nodeKey));
  // pixiGraph.on('nodeMouseup', (event, nodeKey) => console.log('nodeMouseup', event, nodeKey));
  pixiGraph.on('edgeClick', (event, edgeKey, edgeStyle) => {
    // pixiGraph.dragDisable();
    console.log('edgeClick', event, edgeKey, edgeStyle);
  });
  pixiGraph.on('edgeRightclick', (event, edgeKey, edgeStyle) => {
    // pixiGraph.dragDisable();
    console.log('edgeRightclick', event, edgeKey, edgeStyle);
  });
  // pixiGraph.on('edgeMousemove', (event, edgeKey) => console.log('edgeMousemove', event, edgeKey));
  // pixiGraph.on('edgeMouseover', (event, edgeKey) => console.log('edgeMouseover', event, edgeKey));
  // pixiGraph.on('edgeMouseout', (event, edgeKey) => console.log('edgeMouseout', event, edgeKey));
  // pixiGraph.on('edgeMousedown', (event, edgeKey) => console.log('edgeMousedown', event, edgeKey));
  // pixiGraph.on('edgeMouseup', (event, edgeKey) => console.log('edgeMouseup', event, edgeKey));

  // const minX = graph.nodes().reduce((acc, node) => Math.min(acc, graph.getNodeAttribute(node, 'x')), Infinity);
  // const maxX = graph.nodes().reduce((acc, node) => Math.max(acc, graph.getNodeAttribute(node, 'x')), -Infinity);
  // const minY = graph.nodes().reduce((acc, node) => Math.min(acc, graph.getNodeAttribute(node, 'y')), Infinity);
  // const maxY = graph.nodes().reduce((acc, node) => Math.max(acc, graph.getNodeAttribute(node, 'y')), -Infinity);

  const addNode = () => {
  //   const id = Math.floor(Math.random() * 10e12).toString(36);
  //   const x = minX + Math.random() * (maxX - minX);
  //   const y = minY + Math.random() * (maxY - minY);
  //   const node = { id, x, y };

  //   graph.addNode(node.id, node);
    graph.addNode('node5', {
      id: "node5",
      group: 4,
      label: "标签5",
      icon: 'http://127.0.0.1:8080/docs/images/ba.png',
      x: 100,
      y: 200
    });
    graph.addNode('node6', {
      id: "node6",
      group: 1,
      label: "标签6",
      icon: 'http://127.0.0.1:8080/docs/images/ok.png',
      x: 500,
      y: 800
    });
    graph.addEdgeWithKey(`node5->node6`, 'node5', 'node6', {
      source: "node5",
      target: "node6",
      label: "交易500元",
      value: 4
    });
    pixiGraph.resetView(graph.nodes());
  };
  document.getElementById('add-node').addEventListener('click', addNode);

  // const addEdge = () => {
  //   const nodeKeys = graph.nodes();
  //   let source, target;
  //   do {
  //     source = nodeKeys[Math.floor((nodeKeys.length - 1) * Math.random())];
  //     target = nodeKeys[Math.floor((nodeKeys.length - 1) * Math.random())];
  //   } while (graph.edge(source, target));
  //   const link = { source, target };

  //   graph.addEdge(link.source, link.target);
  // };
  // document.getElementById('add-edge').addEventListener('click', addEdge);

  // const dropNode = () => {
  //   const nodeKeys = graph.nodes();
  //   const nodeKey = nodeKeys[Math.floor((nodeKeys.length - 1) * Math.random())];

  //   graph.dropNode(nodeKey);
  // };
  // document.getElementById('drop-node').addEventListener('click', dropNode);

  // const dropEdge = () => {
  //   const edgeKeys = graph.edges();
  //   const edgeKey = edgeKeys[Math.floor((edgeKeys.length - 1) * Math.random())];

  //   graph.dropEdge(edgeKey);
  // };
  // document.getElementById('drop-edge').addEventListener('click', dropEdge);

  // const clear = () => {
  //   graph.clear();
  // };
  // document.getElementById('clear').addEventListener('click', clear);

  // const clearEdges = () => {
  //   graph.clearEdges();
  // };
  // document.getElementById('clear-edges').addEventListener('click', clearEdges);

  // const zoomIn = () => {
  //   pixiGraph.zoomIn();
  // };
  // document.getElementById('zoom-in').addEventListener('click', zoomIn);

  // const zoomOut = () => {
  //   pixiGraph.zoomOut();
  // };
  // document.getElementById('zoom-out').addEventListener('click', zoomOut);

  // const updateNode = () => {
  //   const nodeKeys = graph.nodes();
  //   const nodeKey = nodeKeys[Math.floor((nodeKeys.length - 1) * Math.random())];
  //   const group = graph.getNodeAttribute(nodeKey, 'group');

  //   graph.setNodeAttribute(nodeKey, 'group', (group + 1) % colors.length);
  // };
  // document.getElementById('update-node').addEventListener('click', updateNode);

  // const updateEdge = () => {
  //   const edgeKeys = graph.edges();
  //   const edgeKey = edgeKeys[Math.floor((edgeKeys.length - 1) * Math.random())];
  //   const value = graph.getEdgeAttribute(edgeKey, 'value');

  //   graph.setEdgeAttribute(edgeKey, 'value', value * 50);
  // };
  // document.getElementById('update-edge').addEventListener('click', updateEdge);

  const updateNodes = () => {
    graph.updateEachNodeAttributes((nodeKey, nodeAttributes) => {
      return {
        ...nodeAttributes,
        // group: (nodeAttributes.group + 1) % colors.length
      };
    });
  };
  // document.getElementById('update-nodes').addEventListener('click', updateNodes);

  const updateEdges = () => {
    graph.updateEachEdgeAttributes((edgeKey, edgeAttributes) => {
      return {
        ...edgeAttributes,
        // value: edgeAttributes.value * 50
      };
    });
  };
  // document.getElementById('update-edges').addEventListener('click', updateEdges);

  // const resetView = () => {
  //   pixiGraph.resetView();
  // };
  // document.getElementById('reset-view').addEventListener('click', resetView);

  // let serializedGraph;
  // const exportGraph = () => {
  //   serializedGraph = graph.export();
  //   console.log(serializedGraph);
  // };
  // document.getElementById('export').addEventListener('click', exportGraph);

  // const importGraph = () => {
  //   graph.import(serializedGraph);
  // };
  // document.getElementById('import').addEventListener('click', importGraph);
});
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113550861-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-113550861-4');
</script> -->

</body>
</html>
